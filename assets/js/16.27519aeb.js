(window.webpackJsonp=window.webpackJsonp||[]).push([[16],{288:function(v,_,t){"use strict";t.r(_);var a=t(14),s=Object(a.a)({},(function(){var v=this,_=v._self._c;return _("ContentSlotsDistributor",{attrs:{"slot-key":v.$parent.slotKey}},[_("h2",{attrs:{id:"前言"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#前言"}},[v._v("#")]),v._v(" 前言")]),v._v(" "),_("p",[v._v("有数据库基础的应该都了解到数据库利用索引能达到一个快速的找寻数据的效果。")]),v._v(" "),_("p",[v._v("更深一点的可能了解到索引(InnoDB)是利用B+树去实现的。")]),v._v(" "),_("p",[v._v("但是为什么要用B+树呢？")]),v._v(" "),_("p",[v._v("这世上树那么多,为何独爱这一棵呢？")]),v._v(" "),_("p",[v._v("一切都源于硬件。")]),v._v(" "),_("h2",{attrs:{id:"cpu如何处理数据"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#cpu如何处理数据"}},[v._v("#")]),v._v(" CPU如何处理数据")]),v._v(" "),_("p",[v._v("CPU要处理数据必须从内存中获取,如果内存中没有,那么就要去硬盘上查找了(一般这个查找会交给DMA去处理,CPU可以去做其他事情)。")]),v._v(" "),_("p",[v._v("这个从硬盘查找数据的过程就是IO了。")]),v._v(" "),_("p",[v._v("但是IO是有成本的,不管是什么硬盘都会存在延时。")]),v._v(" "),_("p",[v._v("为什么会有延时呢？ 因为数据放在硬盘里,你需要去找到它并且把它带回内存。")]),v._v(" "),_("p",[v._v("当然CPU和内存的交互不是这么简单的，这里只是说一个大体流程。")]),v._v(" "),_("p",[v._v("所以, 发生IO的次数越少我们应用的性能就越高。")]),v._v(" "),_("p",[v._v("那么, InnoDB引擎在设计时就需要尽可能的保证IO次数少并且支持的数据量还要尽可能的大。")]),v._v(" "),_("h2",{attrs:{id:"索引数据结构的选择"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#索引数据结构的选择"}},[v._v("#")]),v._v(" 索引数据结构的选择")]),v._v(" "),_("h4",{attrs:{id:"hash"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#hash"}},[v._v("#")]),v._v(" Hash")]),v._v(" "),_("p",[v._v("Hash结构确实搜索可以达到O(1)的效果, 但是光不支持范围搜索就毙掉了。")]),v._v(" "),_("h4",{attrs:{id:"二叉树"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#二叉树"}},[v._v("#")]),v._v(" 二叉树")]),v._v(" "),_("ul",[_("li",[v._v("二叉搜索树")])]),v._v(" "),_("p",[v._v("特点是左边小于根节点,右边大于根节点,但是插入新数据不会使之旋转。")]),v._v(" "),_("p",[v._v("这也就导致了一个问题, 插入的数据连续时会退化成一个链表,任何搜索都是扫全表.")]),v._v(" "),_("ul",[_("li",[v._v("AVL搜索树")])]),v._v(" "),_("p",[v._v("也叫强平衡二叉搜索树，特点左右子树的高度相差不能超过1.")]),v._v(" "),_("p",[v._v("这也就导致了它会频繁的发生旋转,影响写入的性能。")]),v._v(" "),_("ul",[_("li",[v._v("红黑树")])]),v._v(" "),_("p",[v._v("特点红色节点的子节点必须是黑色。")]),v._v(" "),_("p",[v._v("每个节点到子节点都必须经过相同的黑色点")]),v._v(" "),_("p",[v._v("这样可以保证不会旋转太频繁,但是树高是不可控的。")]),v._v(" "),_("p",[v._v("树高可以看做是IO次数。")]),v._v(" "),_("h4",{attrs:{id:"多叉树"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#多叉树"}},[v._v("#")]),v._v(" 多叉树")]),v._v(" "),_("ul",[_("li",[v._v("B树")])]),v._v(" "),_("p",[v._v("B树的特点是每个节点都会保存数据.")]),v._v(" "),_("ul",[_("li",[v._v("B+树")])]),v._v(" "),_("p",[v._v("B+树的特点是只有叶子节点会保存数据。")]),v._v(" "),_("ul",[_("li",[v._v("B*树")])]),v._v(" "),_("p",[v._v("InnoDB改造后的B+树,每个节点都保存了指向相邻节点的指针。")]),v._v(" "),_("h2",{attrs:{id:"总结"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#总结"}},[v._v("#")]),v._v(" 总结")]),v._v(" "),_("p",[v._v("任何不考虑硬件特性的程序都是耍流氓。")]),v._v(" "),_("p",[v._v("ps: 数据可视化网址\nhttps://www.cs.usfca.edu/~galles/visualization/Algorithms.html")])])}),[],!1,null,null,null);_.default=s.exports}}]);